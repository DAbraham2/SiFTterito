# SiFT server

useful links:
[link1](https://pycryptodome.readthedocs.io/en/latest/src/cipher/aes.html)
[link2](https://realpython.com/documenting-python-code/)
[link3](https://realpython.com/working-with-files-in-python/)

## TODO
* The Login Protocol is used to authenticate the parties to each other and to establish the secret key between the client and the server to be used by MTP. The server is authenticated implicitly by requiring it to use its private key, whereas the client authenticates itself to the server by sending a username and a password to it. The secret key intended for MTP is derived from random numbers that the client and the server exchange in the Login Protocol. As this secret key is established by the Login Protocol, the messages of the Login Protocol itself cannot be protected by it. Hence, MTP uses a temporary key when executing the Login Protocol, which is replaced by the key established by the Login Protocol when it is completed. The temporary key is generated by the client and it is sent to the server in a login request message, which is encrypted with the server's public key.


* When the server recieves the login request message, it checks the sequence number sqn in the header. Then it takes the last 256 bytes of the message as etk and decrypts it using RSA-OAEP with its RSA private key to obtain the temporary key tk. Once tk is obtained, it can verify the mac and decrypt the epd field using AES in GCM mode with tk as the key and sqn+rnd as the nonce (obtained from the message header). The decrypted payload of the login request contains data that allows the authentication of the client to the server (see the description of the Login Protocol later).

* The server must respond with a login response (type 00 10) message. For building the MTP message that carries the login response, it generates a fresh 6-byte random value r' using a cryptographic random number generator. It fills in the message header fields as follows:
ver = 01 00
typ = 00 10
len is calculated as the sum of the length of the header (16), the length of the encrypted payload (same as the length of the payload), and the length of the mac field (12)
sqn = 00 01 (i.e., this is the first message from the server to the client)
rnd = r' (i.e., the 6-byte fresh random value generated before)
rsv = 00 00

* It then encrypts the payload of the login response and produces an authentication tag on the message header and the encrypted payload using AES in GCM mode with tk as the key and sqn+rnd as the nonce. In this way the epd and mac fields are produced, and the login response is sent to the client.

